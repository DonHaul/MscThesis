
R = generatenoiseR(1)


%assign initial pcs
Rcell = {}
tcell = {}
count=1

for i=1:4
   


  %virginpcs{end+1}=ptCloud
   
  Rcell{end+1}= generatenoiseR(0.1)
  tcell{end+1}=[0 0 0 ]'
  
  
  count=count+1
  
end
%%
pcs = virgincopy
%%
pcs = {pcs{1},pcs{1},pcs{1},pcs{1}}
%%
mergeshow(pcs)
%%
tranfpc = tranformpcs(pcs,Rcell,tcell)
%%
mergeshow(tranfpc)
%%


V= formatpcs(tranfpc')'

%%


% %%% optionally work with less points, donwnsample the point-sets by a factor df >1
df=2; % df=1 means no downsampling
[V,I] = cellfun(@(V) deal(V(1:df:end,1:3)',double(V(1:df:end,4:6))/255),V,'uniformoutput',false);

% initialize centers, the median cardinality can also be used as K but 
% it will dramatically increase the computational complexity without 
%  substantial gain in performance. Higher K can be combined with point-set
%  downsampling to avoid high complexity
%K = 10000;
K = ceil(0.5*median(cellfun(@(V) size(V,2),V))); 

% sample the unit sphere, by randomly selecting azimuth / elevation angles.
az = 2*pi*rand(1,K);
el = 2*pi*rand(1,K);

% (unit) polar to cartesian conversion.
Xin = [cos(az).*cos(el); sin(el); sin(az).*cos(el)];
Xin = Xin% make them have the same order with points (it helps the convergence)


% choose the middle pointset instead to initialize the cluster centers
Xin = V{2}(:,unique(round(linspace(1,size(V{2},2),K))));

Rres,tres= executeJRMPC(pcs,Xin,5)

%%

tranf1pc = tranformpcs(tranfpc,Rres,tres)
mergeshow(tranf1pc)